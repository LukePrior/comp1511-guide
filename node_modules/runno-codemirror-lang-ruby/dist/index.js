import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, delimitedIndent, continuedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@codemirror/highlight';
import { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,nil:16, self:18, true:30, false:30, def:36, end:42};
const parser$1 = /*@__PURE__*/LRParser.deserialize({
  version: 13,
  states: "(|O]QPOOOOQO'#Cc'#CcOOQO'#Cb'#CbOOQO'#Ca'#CaOnQPO'#C`QOQPOOOsQPO'#CcOxQPO'#CvO!WQPO,58zOOQO,58},58}OOQO'#Do'#DoO!wQPO,59bO#RQPO'#CaOOQO'#Cj'#CjO%WQQO'#ClOOQO'#Ch'#ChOOQO'#Cg'#CgOOQO'#Cf'#CfOOQO1G.f1G.fO#dQQO'#CgO%bQPO1G.|OOQO'#Cm'#CmOOQO,59W,59WO%pQPO,59WO%uQPO,59ROOQO7+$h7+$hOOQO1G.r1G.rO&ZQPO'#CpO&iQPO'#CoO&wQPO'#CoO'PQPO'#CpO'UQPO'#CpO]QPO1G.mO'ZQPO,59[O'fQPO,59[O'tQPO,59ZOOQO,59Z,59ZO'yQPO,59[OOQO,59[,59[O(XQPO7+$XOOQO,59^,59^O(^QPO1G.vO(cQPO1G.vO(hQPO1G.vOOQO-E6p-E6pOOQO1G.u1G.uO(sQPO1G.vOOQO<<Gs<<GsOOQO7+$b7+$bO(xQPO7+$bO)WQPO7+$bO)]QPO7+$bP)bQPO'#CrO)gQPO<<G|OOQO<<G|<<G|O)lQPO<<G|O)zQPOAN=hO*PQPOAN=hOOQOG23SG23SO*UQPOG23SOOQOLD(nLD(n",
  stateData: "*Z~OiOSPOSQOS~OWQOXQOkUOlPOmUO~OnWO~OlXO~O!dYO!eYOgjXejX~O]_O__ObcOo]Op]Oq]Or]Os]Ot^O~P]Ogjaeja~P]OgZXnTX!dZX!eZXeZX~OleOueOveOweOxeOyeOzeO{eO|eO}eO!OeO!PeO!QeO!ReO!SeO!TeO!UeO!VeO!WeO!XeO!YeO!ZeO![eO!]eO!^eO!_eO~OkgOmgO~P#dO!dYO!eYOgjieji~OljO~OlkOxoO!TnO!`lO!ddP!edP~O!aqO!ddX!edX!bdX~OlkOxoO!TnO!bdP~O!dYO!eYO~OluO~OlvO~OlxOxyO!TzO~O!a{O!dda!eda!bda~O!b}O~O!a!OO!dda!eda!bda~Oe!PO~Ol!QO~Ol!RO~OlxOx!SO!T!TO~Ox!SO~O!a!VO!ddq!edq!bdq~Ol!WO~Ol!XO~OlxO~Ox!YO~O!a!ZO!ddy!edy!bdy~Ol![O~Ox!]O~Ol!^O~O",
  goto: "$V!dPPPP!e!o!u!}PP#T#W#ZP#^P#^#aP#g#jP#pPPP#vPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP#|SVOpQaWRdZXSOWZpUROZpR[WXQOWZpRbWRaWR`WR_WQf^RhcRphQmhRslQrkR|rQTORwpQZVQidRtm",
  nodeNames: "âš  LineComment BlockComment Program AssignmentExpression LeftHandSide Variable VarName nil self Arg Primary Literal String Number BooleanLiteral Symbol FunctionName def ArgDeclaration ArgumentList end",
  maxTerm: 67,
  skippedNodes: [0,1,2],
  repeatNodeCount: 1,
  tokenData: "2^~RwXY#lYZ$aZ[#lpq#lrs$fst%Ytu%euv%jvw%owx%txy&cyz&hz{&m{|&z|}'X}!O'^!O!P'k!P!Q)P!Q!R)U!R![*Y![!]-r!]!^-w!^!_-|!_!`.k!`!a0m!b!c1S!c!}1X!}#O1j#Q#R1}#T#o1X#p#q2S#r#s2X$f$g#l#BY#BZ#l$IS$I_#l$JT$JU#l$KV$KW#l&FU&FV#l?HT?HU#l~#qYi~XY#lZ[#lpq#l$f$g#l#BY#BZ#l$IS$I_#l$JT$JU#l$KV$KW#l&FU&FV#l?HT?HU#l~$fO!e~~$kU]~OY$fZr$frs$}s#O$f#O#P%S#P~$f~%SO]~~%VPO~$f~%_QP~OY%YZ~%Y~%jOk~~%oO!V~~%tOx~~%yU]~OY%tZw%twx$}x#O%t#O#P&]#P~%t~&`PO~%t~&hO!`~~&mO!b~~&rP!T~z{&u~&zO!W~~'PP!R~!b!c'S~'XO![~~'^O!a~~'cP!S~!b!c'f~'kO!]~~'nQ!O!P't!Q!['y~'yOu~~(OSo~!Q!['y!g!h([#R#S'y#X#Y([~(_S{|(k}!O(k!Q![(t#R#S(t~(nQ!Q![(t#R#S(t~(yQo~!Q![(t#R#S(t~)UO!U~~)Z_o~!O!P'y!Q![*Y!d!e*y!f!g+p!g!h([!q!r,U!z!{,u#R#S*Y#U#V*y#W#X+p#X#Y([#]#^*t#c#d,U#f#g*t#l#m,u~*_Vo~!O!P'y!Q![*Y!g!h([#R#S*Y#X#Y([#]#^*t#f#g*t~*yOo~~*|R!Q!R+V!R!S+V#R#S+V~+[Ts~!Q!R+V!R!S+V#R#S+V#]#^+k#f#g+k~+pOs~~+sQ!Q![+y#R#S+y~,OQp~!Q![+y#R#S+y~,XQ!Q!Y,_#R#S,_~,dSr~!Q!Y,_#R#S,_#]#^,p#f#g,p~,uOr~~,xS!Q![-U!c!i-U#R#S-U#T#Z-U~-ZUq~!Q![-U!c!i-U#R#S-U#T#Z-U#]#^-m#f#g-m~-rOq~~-wOt~~-|O!d~~.RQ!P~!^!_.X!_!`.^~.^O!X~~.cP!Q~!`!a.f~.kOy~~.pRnP!_!`.y#U#V/W#r#s0hQ/OPzQ!_!`/RQ/WO{Q~/ZP#X#Y/^~/aP#Z#[/d~/gP#]#^/j~/mP#b#c/p~/sRO!_/p!_!`/|!`~/p~0PQ!_!`/|#X#Y0V~0YP#b#c0]~0`P#W#X0c~0hOQ~Q0mO|Q~0rQ}~!_!`0x!`!a0}~0}O!O~~1SO!Y~~1XOm~~1^Sl~!Q![1X!c!}1X#R#S1X#T#o1X~1mP#P#Q1p~1uP!^~!_!`1x~1}O!_~~2SOw~~2XOv~~2^O!Z~",
  tokenizers: [0, 1],
  topRules: {"Program":[0,3]},
  specialized: [{term: 28, get: value => spec_identifier[value] || -1}],
  tokenPrec: 0
});

const parser = parser$1;
const rubyLanguage = /*@__PURE__*/LRLanguage.define({
    parser: /*@__PURE__*/parser.configure({
        props: [
            /*@__PURE__*/indentNodeProp.add({
                Parenthesized: /*@__PURE__*/delimitedIndent({ closing: ")" }),
                AttrSet: /*@__PURE__*/delimitedIndent({ closing: "}" }),
                List: /*@__PURE__*/delimitedIndent({ closing: "]" }),
                Let: /*@__PURE__*/continuedIndent({ except: /^\s*in\b/ }),
            }),
            /*@__PURE__*/foldNodeProp.add({
                AttrSet: foldInside,
                List: foldInside,
                Let(node) {
                    let first = node.getChild("let"), last = node.getChild("in");
                    if (!first || !last)
                        return null;
                    return { from: first.to, to: last.from };
                },
            }),
            /*@__PURE__*/styleTags({
                "for while do if else switch begin rescue ensure return throw break continue default case": tags.controlKeyword,
                "def end": tags.definitionKeyword,
                VarName: tags.variableName,
                BooleanLiteral: tags.bool,
                String: tags.string,
                LineComment: tags.lineComment,
                BlockComment: tags.blockComment,
                // Float: t.float,
                Number: tags.integer,
                Symbol: tags.atom,
                Null: tags.null,
                "( )": tags.paren,
                "{ }": tags.brace,
                "[ ]": tags.squareBracket,
                "if then else unless": tags.controlKeyword,
                "import with let in rec builtins inherit assert or": tags.keyword,
                ", ;": tags.separator,
            }),
        ],
    }),
    languageData: {
        commentTokens: { line: "#", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "''", '"'] },
        indentOnInput: /^\s*(in|\}|\)|\])$/,
    },
});
const snippets = [
    /*@__PURE__*/snippetCompletion("let ${binds} in ${expression}", {
        label: "let",
        detail: "Let ... in statement",
        type: "keyword",
    }),
    /*@__PURE__*/snippetCompletion("with ${expression}; ${expression}", {
        label: "with",
        detail: "With statement",
        type: "keyword",
    }),
];
function ruby() {
    return new LanguageSupport(rubyLanguage, rubyLanguage.data.of({
        autocomplete: ifNotIn(["LineComment", "BlockComment", "String", "IndentedString"], completeFromList(snippets)),
    }));
}

export { parser, ruby, rubyLanguage };
